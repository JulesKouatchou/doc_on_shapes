var tipuesearch = {"pages":[{"title":" Testing FORD Features in a Modern Fortran Application ","text":"Testing FORD Features in a Modern Fortran Application Using OOP to Define a Geometric Shape Class We use Modern Fortran features to write an OOP application\nthat highlights abstraction, encapsulation and inheritance.\nThe application creates a parent shape class that is used to\ndefines various geometric shapes.\nFor each child gemetric shape, we want to be able to compute\nthe area and the perimeter. Developer Info GMAO SI-Team GEOS Software Infrastructure Team","tags":"home","loc":"index.html"},{"title":"ellipse – Testing FORD Features in a Modern Fortran Application ","text":"type, public, extends( shape ) :: ellipse Inherits type~~ellipse~~InheritsGraph type~ellipse ellipse type~shape shape type~ellipse->type~shape Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~ellipse~~InheritedByGraph type~ellipse ellipse type~circle circle type~circle->type~ellipse Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a b Constructor ellipse Type-Bound Procedures get_area get_name get_perimeter Source Code ellipse Components Type Visibility Attributes Name Initial real, private :: a semi-major axe real, private :: b semi-minor axe Constructor public interface ellipse private function new_ellipse (a, b, name) result(a_ellipse) Initialize an arbitrary ellipse by passing the\nthe  semi-major and semi-minor axes, and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b character(len=:), allocatable :: name Return Value type( ellipse ) Type-Bound Procedures procedure, public :: get_area private function get_area (this) Compute the area of an ellipse using the formula: Read more… Arguments Type Intent Optional Attributes Name class( ellipse ), intent(in) :: this Return Value real procedure, public, non_overridable :: get_name private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable procedure, public :: get_perimeter private function get_perimeter (this) Compute the perimeter of an ellipse using the formula: Read more… Arguments Type Intent Optional Attributes Name class( ellipse ), intent(in) :: this Return Value real Source Code type , extends ( shape ) :: ellipse real :: a !! semi-major axe real :: b !! semi-minor axe contains procedure :: get_area procedure :: get_perimeter end type ellipse","tags":"","loc":"type/ellipse.html"},{"title":"shape – Testing FORD Features in a Modern Fortran Application ","text":"type, public, abstract :: shape Base class for geometric shape types Inherited by type~~shape~~InheritedByGraph type~shape shape type~list_of_shapes list_of_shapes type~list_of_shapes->type~shape shap type~polygon polygon type~polygon->type~shape type~ellipse ellipse type~ellipse->type~shape type~rectangle rectangle type~rectangle->type~polygon type~circle circle type~circle->type~ellipse type~triangle triangle type~triangle->type~polygon type~square square type~square->type~rectangle Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables name Type-Bound Procedures get_area get_name get_perimeter Source Code shape Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: name Type-Bound Procedures procedure( get_shape_area ), public, deferred :: get_area function get_shape_area(this) Prototype Interface for determining the area. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value real procedure, public, non_overridable :: get_name private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable procedure( get_shape_perimeter ), public, deferred :: get_perimeter function get_shape_perimeter(this) Prototype Interface for determining the perimeter. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value real Source Code type , abstract :: shape !! Base class for geometric shape types character ( len = :), allocatable :: name contains procedure ( get_shape_area ), deferred :: get_area procedure ( get_shape_perimeter ), deferred :: get_perimeter procedure , non_overridable :: get_name end type shape","tags":"","loc":"type/shape.html"},{"title":"square – Testing FORD Features in a Modern Fortran Application ","text":"type, public, extends( rectangle ) :: square Inherits type~~square~~InheritsGraph type~square square type~rectangle rectangle type~square->type~rectangle type~polygon polygon type~rectangle->type~polygon type~shape shape type~polygon->type~shape Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Constructor square Type-Bound Procedures get_area get_name get_perimeter Source Code square Constructor public interface square private function new_square (length, name) result(a_square) Initialize a square by passing the\nthe length and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length character(len=:), allocatable :: name Return Value type( square ) Type-Bound Procedures procedure, public :: get_area private function get_area (this) Deterime the area of q square. Arguments Type Intent Optional Attributes Name class( square ), intent(in) :: this Return Value real procedure, public, non_overridable :: get_name private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable procedure, public :: get_perimeter private function get_perimeter (this) Deterime the perimeter of q square. Arguments Type Intent Optional Attributes Name class( square ), intent(in) :: this Return Value real Source Code type , extends ( rectangle ) :: square contains procedure :: get_area procedure :: get_perimeter end type square","tags":"","loc":"type/square.html"},{"title":"polygon – Testing FORD Features in a Modern Fortran Application ","text":"type, public, extends( shape ) :: polygon Derived type to define a polygon using\narrays of x and y coordinates traced in a clockwise\ndirection, starting at any vertex. Inherits type~~polygon~~InheritsGraph type~polygon polygon type~shape shape type~polygon->type~shape Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~polygon~~InheritedByGraph type~polygon polygon type~rectangle rectangle type~rectangle->type~polygon type~triangle triangle type~triangle->type~polygon type~square square type~square->type~rectangle Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_coords y_coords Constructor polygon Type-Bound Procedures get_area get_name get_perimeter Source Code polygon Components Type Visibility Attributes Name Initial real, private, pointer :: x_coords (:) => null() real, private, pointer :: y_coords (:) => null() Constructor public interface polygon private function new_polygon (xc, yc, name) Initialize an arbitrary polygon by passing the\ntwo arrays of coordinatesand and a name. Arguments Type Intent Optional Attributes Name real, target :: xc (:) real, target :: yc (:) character(len=:), allocatable :: name Return Value type( polygon ) Type-Bound Procedures procedure, public :: get_area private function get_area (this) result(area) Determine the area of a simple polygon. Arguments Type Intent Optional Attributes Name class( polygon ), intent(in) :: this Return Value real procedure, public, non_overridable :: get_name private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable procedure, public :: get_perimeter private function get_perimeter (this) result(perimeter) Arguments Type Intent Optional Attributes Name class( polygon ), intent(in) :: this Return Value real Source Code type , extends ( shape ) :: polygon !! Derived type to define a polygon using !! arrays of x and y coordinates traced in a clockwise !! direction, starting at any vertex. real , pointer :: x_coords (:) => null () real , pointer :: y_coords (:) => null () contains procedure :: get_area procedure :: get_perimeter end type polygon","tags":"","loc":"type/polygon.html"},{"title":"list_of_shapes – Testing FORD Features in a Modern Fortran Application ","text":"type :: list_of_shapes Inherits type~~list_of_shapes~~InheritsGraph type~list_of_shapes list_of_shapes type~shape shape type~list_of_shapes->type~shape shap Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables shap Source Code list_of_shapes Components Type Visibility Attributes Name Initial class( shape ), public, pointer :: shap Source Code type list_of_shapes class ( shape ), pointer :: shap end type list_of_shapes","tags":"","loc":"type/list_of_shapes.html"},{"title":"circle – Testing FORD Features in a Modern Fortran Application ","text":"type, public, extends( ellipse ) :: circle Inherits type~~circle~~InheritsGraph type~circle circle type~ellipse ellipse type~circle->type~ellipse type~shape shape type~ellipse->type~shape Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables radius Constructor circle Type-Bound Procedures get_area get_name get_perimeter print_circle_info Source Code circle Components Type Visibility Attributes Name Initial real, private :: radius Constructor public interface circle private function new_circle (radius, name) result(a_circle) Initialize a circle by passing the radius\nand a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: radius character(len=:), allocatable :: name Return Value type( circle ) Type-Bound Procedures procedure, public :: get_area private function get_area (this) Compute the area of a circle using the formula: Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Return Value real procedure, public, non_overridable :: get_name private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable procedure, public :: get_perimeter private function get_perimeter (this) Compute the perimeter of a circle using the formula: Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Return Value real procedure, public :: print_circle_info private subroutine print_circle_info (this) Print information (radius, area, perimeter) of a circle. Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Source Code type , extends ( ellipse ) :: circle real :: radius contains procedure :: get_area procedure :: get_perimeter procedure :: print_circle_info end type circle","tags":"","loc":"type/circle.html"},{"title":"rectangle – Testing FORD Features in a Modern Fortran Application ","text":"type, public, extends( polygon ) :: rectangle Inherits type~~rectangle~~InheritsGraph type~rectangle rectangle type~polygon polygon type~rectangle->type~polygon type~shape shape type~polygon->type~shape Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~rectangle~~InheritedByGraph type~rectangle rectangle type~square square type~square->type~rectangle Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables length width Constructor rectangle Type-Bound Procedures get_area get_name get_perimeter Source Code rectangle Components Type Visibility Attributes Name Initial real, private :: length real, private :: width Constructor public interface rectangle private function new_rectangle (length, width, name) result(a_rectangle) Initialize an arbitrary rectangle by passing the\nlength, the width and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length real, intent(in) :: width character(len=:), allocatable :: name Return Value type( rectangle ) Type-Bound Procedures procedure, public :: get_area private function get_area (this) Compute the area of a reactangle Arguments Type Intent Optional Attributes Name class( rectangle ), intent(in) :: this Return Value real procedure, public, non_overridable :: get_name private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable procedure, public :: get_perimeter private function get_perimeter (this) Compute the perimeter of a reactangle Arguments Type Intent Optional Attributes Name class( rectangle ), intent(in) :: this Return Value real Source Code type , extends ( polygon ) :: rectangle real :: length real :: width contains procedure :: get_area procedure :: get_perimeter end type rectangle","tags":"","loc":"type/rectangle.html"},{"title":"triangle – Testing FORD Features in a Modern Fortran Application ","text":"type, public, extends( polygon ) :: triangle Inherits type~~triangle~~InheritsGraph type~triangle triangle type~polygon polygon type~triangle->type~polygon type~shape shape type~polygon->type~shape Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a b c Constructor triangle Type-Bound Procedures get_area get_name get_perimeter Source Code triangle Components Type Visibility Attributes Name Initial real, private :: a opposite real, private :: b adjacent real, private :: c hypotenus Constructor public interface triangle private function new_triangle (a, b, c, name) result(a_triangle) Initialize an arbitrary triangle by passing the\nthe three sides (opposite, adjacent and hypotenus) and\na name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a opposite real, intent(in) :: b adjacent real, intent(in) :: c hypotenuse character(len=:), allocatable :: name Return Value type( triangle ) Type-Bound Procedures procedure, public :: get_area private function get_area (this) Compute the area of a triangle using the Heron’s formula: Read more… Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value real procedure, public, non_overridable :: get_name private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable procedure, public :: get_perimeter private function get_perimeter (this) Compute the perimeter of a triangle. Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value real Source Code type , extends ( polygon ) :: triangle real :: a !! opposite real :: b !! adjacent real :: c !! hypotenus contains procedure :: get_area procedure :: get_perimeter end type triangle","tags":"","loc":"type/triangle.html"},{"title":"get_shape_area – Testing FORD Features in a Modern Fortran Application","text":"abstract interface private function get_shape_area(this) Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value real Description Interface for determining the area.","tags":"","loc":"interface/get_shape_area.html"},{"title":"get_shape_perimeter – Testing FORD Features in a Modern Fortran Application","text":"abstract interface private function get_shape_perimeter(this) Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value real Description Interface for determining the perimeter.","tags":"","loc":"interface/get_shape_perimeter.html"},{"title":"get_area – Testing FORD Features in a Modern Fortran Application","text":"private function get_area(this) Compute the area of an ellipse using the formula: Arguments Type Intent Optional Attributes Name class( ellipse ), intent(in) :: this Return Value real Contents Source Code get_area Source Code real function get_area ( this ) class ( ellipse ), intent ( in ) :: this get_area = PI * this % a * this % b end function get_area","tags":"","loc":"proc/get_area.html"},{"title":"get_perimeter – Testing FORD Features in a Modern Fortran Application","text":"private function get_perimeter(this) Compute the perimeter of an ellipse using the formula: Arguments Type Intent Optional Attributes Name class( ellipse ), intent(in) :: this Return Value real Contents Source Code get_perimeter Source Code real function get_perimeter ( this ) class ( ellipse ), intent ( in ) :: this real :: h , terms integer :: i h = ( ( this % a - this % b ) ** 2 ) / ( ( this % a + this % b ) ** 2 ) terms = 1.0 + 0.25 * h + ( 1. / 6 4. ) * h ** 2 + ( 1. / 25 6. ) * h ** 3 + & ( 2 5. / 1638 4. ) * h ** 4 + ( 4 9. / 6553 6. ) * h ** 5 + ( 44 1. / 104857 6. ) * h ** 6 get_perimeter = PI * ( this % a + this % b ) * terms !      ! Ramanujan's approximation !      associate (a=>this%a, b=>this%b) !        get_perimeter = PI * (3.0*(a+b) - sqrt( (3.0*a+b)*(a+3.0*b) )) !      end associate end function get_perimeter","tags":"","loc":"proc/get_perimeter.html"},{"title":"new_ellipse – Testing FORD Features in a Modern Fortran Application","text":"private function new_ellipse(a, b, name) result(a_ellipse) Initialize an arbitrary ellipse by passing the\nthe  semi-major and semi-minor axes, and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b character(len=:), allocatable :: name Return Value type( ellipse ) Called by proc~~new_ellipse~~CalledByGraph proc~new_ellipse new_ellipse interface~ellipse ellipse interface~ellipse->proc~new_ellipse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code new_ellipse Source Code function new_ellipse ( a , b , name ) result ( a_ellipse ) real , intent ( in ) :: a ! semi-major axe real , intent ( in ) :: b ! semi-minor axe character ( len = :), allocatable :: name type ( ellipse ) :: a_ellipse a_ellipse % a = a a_ellipse % b = b a_ellipse % name = name end function new_ellipse","tags":"","loc":"proc/new_ellipse.html"},{"title":"ellipse – Testing FORD Features in a Modern Fortran Application","text":"public interface ellipse Calls interface~~ellipse~~CallsGraph interface~ellipse ellipse proc~new_ellipse new_ellipse interface~ellipse->proc~new_ellipse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures new_ellipse Module Procedures private function new_ellipse (a, b, name) result(a_ellipse) Initialize an arbitrary ellipse by passing the\nthe  semi-major and semi-minor axes, and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b character(len=:), allocatable :: name Return Value type( ellipse )","tags":"","loc":"interface/ellipse.html"},{"title":"get_name – Testing FORD Features in a Modern Fortran Application","text":"private function get_name(this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable Contents Source Code get_name Source Code function get_name ( this ) result ( name ) class ( shape ), intent ( in ) :: this character ( len = :), allocatable :: name name = this % name end function get_name","tags":"","loc":"proc/get_name.html"},{"title":"get_area – Testing FORD Features in a Modern Fortran Application","text":"private function get_area(this) Deterime the area of q square. Arguments Type Intent Optional Attributes Name class( square ), intent(in) :: this Return Value real Contents Source Code get_area Source Code real function get_area ( this ) class ( square ), intent ( in ) :: this get_area = this % length * this % length end function get_area","tags":"","loc":"proc/get_area~2.html"},{"title":"get_perimeter – Testing FORD Features in a Modern Fortran Application","text":"private function get_perimeter(this) Deterime the perimeter of q square. Arguments Type Intent Optional Attributes Name class( square ), intent(in) :: this Return Value real Contents Source Code get_perimeter Source Code real function get_perimeter ( this ) class ( square ), intent ( in ) :: this get_perimeter = 4.0 * this % length end function get_perimeter","tags":"","loc":"proc/get_perimeter~2.html"},{"title":"new_square – Testing FORD Features in a Modern Fortran Application","text":"private function new_square(length, name) result(a_square) Initialize a square by passing the\nthe length and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length character(len=:), allocatable :: name Return Value type( square ) Called by proc~~new_square~~CalledByGraph proc~new_square new_square interface~square square interface~square->proc~new_square Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code new_square Source Code function new_square ( length , name ) result ( a_square ) real , intent ( in ) :: length character ( len = :), allocatable :: name type ( square ) :: a_square a_square % length = length a_square % name = name end function new_square","tags":"","loc":"proc/new_square.html"},{"title":"square – Testing FORD Features in a Modern Fortran Application","text":"public interface square Calls interface~~square~~CallsGraph interface~square square proc~new_square new_square interface~square->proc~new_square Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures new_square Module Procedures private function new_square (length, name) result(a_square) Initialize a square by passing the\nthe length and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length character(len=:), allocatable :: name Return Value type( square )","tags":"","loc":"interface/square.html"},{"title":"get_area – Testing FORD Features in a Modern Fortran Application","text":"private function get_area(this) result(area) Determine the area of a simple polygon. Arguments Type Intent Optional Attributes Name class( polygon ), intent(in) :: this Return Value real Calls proc~~get_area~3~~CallsGraph proc~get_area~3 get_area x x proc~get_area~3->x y y proc~get_area~3->y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_area Source Code function get_area ( this ) result ( area ) class ( polygon ), intent ( in ) :: this real :: area integer :: i , num_points area = 0.0 num_points = size ( this % x_coords ) associate ( x => this % x_coords , y => this % y_coords , n => num_points ) do i = 1 , n - 1 area = area + ( x ( i ) * y ( i + 1 )) - ( x ( i + 1 ) * y ( i )) end do area = area + x ( n ) * y ( 1 ) - x ( 1 ) * y ( n ) end associate area = abs ( area ) / 2.0 end function get_area","tags":"","loc":"proc/get_area~3.html"},{"title":"get_perimeter – Testing FORD Features in a Modern Fortran Application","text":"private function get_perimeter(this) result(perimeter) Arguments Type Intent Optional Attributes Name class( polygon ), intent(in) :: this Return Value real Calls proc~~get_perimeter~6~~CallsGraph proc~get_perimeter~6 get_perimeter x x proc~get_perimeter~6->x y y proc~get_perimeter~6->y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_perimeter Source Code function get_perimeter ( this ) result ( perimeter ) class ( polygon ), intent ( in ) :: this real :: perimeter integer :: i , num_points perimeter = 0.0 num_points = size ( this % x_coords ) associate ( x => this % x_coords , y => this % y_coords , n => num_points ) do i = 1 , n - 1 perimeter = perimeter + sqrt ( ( x ( i + 1 ) - x ( i )) ** 2 + ( y ( i + 1 ) - y ( i )) ** 2 ) end do ! last point perimeter = perimeter + sqrt ( ( x ( 1 ) - x ( n )) ** 2 + ( y ( 1 ) - y ( n )) ** 2 ) end associate end function get_perimeter","tags":"","loc":"proc/get_perimeter~6.html"},{"title":"new_polygon – Testing FORD Features in a Modern Fortran Application","text":"private function new_polygon(xc, yc, name) Initialize an arbitrary polygon by passing the\ntwo arrays of coordinatesand and a name. Arguments Type Intent Optional Attributes Name real, target :: xc (:) real, target :: yc (:) character(len=:), allocatable :: name Return Value type( polygon ) Called by proc~~new_polygon~~CalledByGraph proc~new_polygon new_polygon interface~polygon polygon interface~polygon->proc~new_polygon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code new_polygon Source Code function new_polygon ( xc , yc , name ) real , target :: xc (:) real , target :: yc (:) character ( len = :), allocatable :: name type ( polygon ) :: new_polygon new_polygon % x_coords => xc new_polygon % y_coords => yc new_polygon % name = name end function new_polygon","tags":"","loc":"proc/new_polygon.html"},{"title":"polygon – Testing FORD Features in a Modern Fortran Application","text":"public interface polygon Calls interface~~polygon~~CallsGraph interface~polygon polygon proc~new_polygon new_polygon interface~polygon->proc~new_polygon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures new_polygon Module Procedures private function new_polygon (xc, yc, name) Initialize an arbitrary polygon by passing the\ntwo arrays of coordinatesand and a name. Arguments Type Intent Optional Attributes Name real, target :: xc (:) real, target :: yc (:) character(len=:), allocatable :: name Return Value type( polygon )","tags":"","loc":"interface/polygon.html"},{"title":"get_area – Testing FORD Features in a Modern Fortran Application","text":"private function get_area(this) Compute the area of a circle using the formula: Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Return Value real Called by proc~~get_area~4~~CalledByGraph proc~get_area~4 get_area proc~print_circle_info print_circle_info proc~print_circle_info->proc~get_area~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_area Source Code real function get_area ( this ) class ( circle ), intent ( in ) :: this get_area = PI * this % radius ** 2 end function get_area","tags":"","loc":"proc/get_area~4.html"},{"title":"get_perimeter – Testing FORD Features in a Modern Fortran Application","text":"private function get_perimeter(this) Compute the perimeter of a circle using the formula: Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Return Value real Called by proc~~get_perimeter~3~~CalledByGraph proc~get_perimeter~3 get_perimeter proc~print_circle_info print_circle_info proc~print_circle_info->proc~get_perimeter~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_perimeter Source Code real function get_perimeter ( this ) class ( circle ), intent ( in ) :: this get_perimeter = 2.0 * PI * this % radius end function get_perimeter","tags":"","loc":"proc/get_perimeter~3.html"},{"title":"new_circle – Testing FORD Features in a Modern Fortran Application","text":"private function new_circle(radius, name) result(a_circle) Initialize a circle by passing the radius\nand a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: radius character(len=:), allocatable :: name Return Value type( circle ) Called by proc~~new_circle~~CalledByGraph proc~new_circle new_circle interface~circle circle interface~circle->proc~new_circle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code new_circle Source Code function new_circle ( radius , name ) result ( a_circle ) real , intent ( in ) :: radius character ( len = :), allocatable :: name type ( circle ) :: a_circle a_circle % radius = radius a_circle % name = name end function new_circle","tags":"","loc":"proc/new_circle.html"},{"title":"print_circle_info – Testing FORD Features in a Modern Fortran Application","text":"private subroutine print_circle_info(this) Print information (radius, area, perimeter) of a circle. Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Calls proc~~print_circle_info~~CallsGraph proc~print_circle_info print_circle_info circle_area circle_area proc~print_circle_info->circle_area proc~get_area~4 get_area proc~print_circle_info->proc~get_area~4 proc~get_perimeter~3 get_perimeter proc~print_circle_info->proc~get_perimeter~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_circle_info Source Code subroutine print_circle_info ( this ) class ( circle ), intent ( in ) :: this area = circle_area ( this ) ! Call the circle_area function print '(a15)' , 'Circle:' print '(a18)' , '      Radius = ' , this % radius print '(a18)' , '        Area = ' , get_area ( this ) print '(a18)' , '   Perimeter = ' , get_perimeter ( this ) print * , 'Circle: r = ' , this % radius , ' area = ' , area end subroutine print_circle_info","tags":"","loc":"proc/print_circle_info.html"},{"title":"circle – Testing FORD Features in a Modern Fortran Application","text":"public interface circle Calls interface~~circle~~CallsGraph interface~circle circle proc~new_circle new_circle interface~circle->proc~new_circle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures new_circle Module Procedures private function new_circle (radius, name) result(a_circle) Initialize a circle by passing the radius\nand a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: radius character(len=:), allocatable :: name Return Value type( circle )","tags":"","loc":"interface/circle.html"},{"title":"get_area – Testing FORD Features in a Modern Fortran Application","text":"private function get_area(this) Compute the area of a reactangle Arguments Type Intent Optional Attributes Name class( rectangle ), intent(in) :: this Return Value real Contents Source Code get_area Source Code real function get_area ( this ) class ( rectangle ), intent ( in ) :: this get_area = this % width * this % length end function get_area","tags":"","loc":"proc/get_area~5.html"},{"title":"get_perimeter – Testing FORD Features in a Modern Fortran Application","text":"private function get_perimeter(this) Compute the perimeter of a reactangle Arguments Type Intent Optional Attributes Name class( rectangle ), intent(in) :: this Return Value real Contents Source Code get_perimeter Source Code real function get_perimeter ( this ) class ( rectangle ), intent ( in ) :: this get_perimeter = 2.0 * ( this % width + this % length ) end function get_perimeter","tags":"","loc":"proc/get_perimeter~4.html"},{"title":"new_rectangle – Testing FORD Features in a Modern Fortran Application","text":"private function new_rectangle(length, width, name) result(a_rectangle) Initialize an arbitrary rectangle by passing the\nlength, the width and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length real, intent(in) :: width character(len=:), allocatable :: name Return Value type( rectangle ) Called by proc~~new_rectangle~~CalledByGraph proc~new_rectangle new_rectangle interface~rectangle rectangle interface~rectangle->proc~new_rectangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code new_rectangle Source Code function new_rectangle ( length , width , name ) result ( a_rectangle ) real , intent ( in ) :: length , width character ( len = :), allocatable :: name type ( rectangle ) :: a_rectangle a_rectangle % length = length a_rectangle % width = width a_rectangle % name = name end function new_rectangle","tags":"","loc":"proc/new_rectangle.html"},{"title":"rectangle – Testing FORD Features in a Modern Fortran Application","text":"public interface rectangle Calls interface~~rectangle~~CallsGraph interface~rectangle rectangle proc~new_rectangle new_rectangle interface~rectangle->proc~new_rectangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures new_rectangle Module Procedures private function new_rectangle (length, width, name) result(a_rectangle) Initialize an arbitrary rectangle by passing the\nlength, the width and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length real, intent(in) :: width character(len=:), allocatable :: name Return Value type( rectangle )","tags":"","loc":"interface/rectangle.html"},{"title":"is_right_triangle – Testing FORD Features in a Modern Fortran Application","text":"private function is_right_triangle(this) Determine if a triangle is a right one by\nchecking if the Pythagorean formula is true: Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value logical Contents Source Code is_right_triangle Source Code logical function is_right_triangle ( this ) class ( triangle ), intent ( in ) :: this is_right_triangle = . FALSE . if ( ( this % a ** 2 + this % b ** 2 ) == this % c ** 2 ) is_right_triangle = . TRUE . end function is_right_triangle","tags":"","loc":"proc/is_right_triangle.html"},{"title":"get_area – Testing FORD Features in a Modern Fortran Application","text":"private function get_area(this) Compute the area of a triangle using the Heron’s formula: Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value real Contents Source Code get_area Source Code real function get_area ( this ) class ( triangle ), intent ( in ) :: this real :: s s = ( this % a + this % b + this % c ) / 2.0 get_area = sqrt ( s * ( s - this % a ) * ( s - this % b ) * ( s - this % c )) end function get_area","tags":"","loc":"proc/get_area~6.html"},{"title":"get_perimeter – Testing FORD Features in a Modern Fortran Application","text":"private function get_perimeter(this) Compute the perimeter of a triangle. Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value real Contents Source Code get_perimeter Source Code real function get_perimeter ( this ) class ( triangle ), intent ( in ) :: this get_perimeter = this % a + this % b + this % c end function get_perimeter","tags":"","loc":"proc/get_perimeter~5.html"},{"title":"new_triangle – Testing FORD Features in a Modern Fortran Application","text":"private function new_triangle(a, b, c, name) result(a_triangle) Initialize an arbitrary triangle by passing the\nthe three sides (opposite, adjacent and hypotenus) and\na name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a opposite real, intent(in) :: b adjacent real, intent(in) :: c hypotenuse character(len=:), allocatable :: name Return Value type( triangle ) Called by proc~~new_triangle~~CalledByGraph proc~new_triangle new_triangle interface~triangle triangle interface~triangle->proc~new_triangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code new_triangle Source Code function new_triangle ( a , b , c , name ) result ( a_triangle ) real , intent ( in ) :: a !! opposite real , intent ( in ) :: b !! adjacent real , intent ( in ) :: c !! hypotenuse character ( len = :), allocatable :: name type ( triangle ) :: a_triangle a_triangle % a = a a_triangle % b = b a_triangle % c = c a_triangle % name = name end function new_triangle","tags":"","loc":"proc/new_triangle.html"},{"title":"triangle – Testing FORD Features in a Modern Fortran Application","text":"public interface triangle Calls interface~~triangle~~CallsGraph interface~triangle triangle proc~new_triangle new_triangle interface~triangle->proc~new_triangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures new_triangle Module Procedures private function new_triangle (a, b, c, name) result(a_triangle) Initialize an arbitrary triangle by passing the\nthe three sides (opposite, adjacent and hypotenus) and\na name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a opposite real, intent(in) :: b adjacent real, intent(in) :: c hypotenuse character(len=:), allocatable :: name Return Value type( triangle )","tags":"","loc":"interface/triangle.html"},{"title":"ellipse_mod – Testing FORD Features in a Modern Fortran Application","text":"MODULE: ellipse_mod Define the ellipse shape and\n create methods to obtain its features. Uses shapes_mod module~~ellipse_mod~~UsesGraph module~ellipse_mod ellipse_mod module~shapes_mod shapes_mod module~ellipse_mod->module~shapes_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ellipse_mod~~UsedByGraph module~ellipse_mod ellipse_mod module~circle_mod circle_mod module~circle_mod->module~ellipse_mod program~test_shapes test_shapes program~test_shapes->module~ellipse_mod program~test_shapes->module~circle_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables PI Interfaces ellipse Derived Types ellipse Functions get_area get_perimeter new_ellipse Variables Type Visibility Attributes Name Initial real, public, parameter :: PI = 4.0*atan(1.0) Interfaces public interface ellipse private function new_ellipse (a, b, name) result(a_ellipse) Initialize an arbitrary ellipse by passing the\nthe  semi-major and semi-minor axes, and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b character(len=:), allocatable :: name Return Value type( ellipse ) Derived Types type, public, extends( shape ) :: ellipse Components Type Visibility Attributes Name Initial real, private :: a semi-major axe real, private :: b semi-minor axe Constructor private  function new_ellipse (a, b, name) Initialize an arbitrary ellipse by passing the\nthe  semi-major and semi-minor axes, and a name. Type-Bound Procedures procedure, public :: get_area procedure, public, non_overridable :: get_name procedure, public :: get_perimeter Functions private function get_area (this) Compute the area of an ellipse using the formula: Read more… Arguments Type Intent Optional Attributes Name class( ellipse ), intent(in) :: this Return Value real private function get_perimeter (this) Compute the perimeter of an ellipse using the formula: Read more… Arguments Type Intent Optional Attributes Name class( ellipse ), intent(in) :: this Return Value real private function new_ellipse (a, b, name) result(a_ellipse) Initialize an arbitrary ellipse by passing the\nthe  semi-major and semi-minor axes, and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b character(len=:), allocatable :: name Return Value type( ellipse )","tags":"","loc":"module/ellipse_mod.html"},{"title":"shapes_mod – Testing FORD Features in a Modern Fortran Application","text":"MODULE: shape_class Parent class that will be used to define various geometric shapes. For aech define shape, we want to be to determine its area and perimeter. Used by module~~shapes_mod~~UsedByGraph module~shapes_mod shapes_mod module~ellipse_mod ellipse_mod module~ellipse_mod->module~shapes_mod program~test_shapes test_shapes program~test_shapes->module~shapes_mod program~test_shapes->module~ellipse_mod module~polygon_mod polygon_mod program~test_shapes->module~polygon_mod module~circle_mod circle_mod program~test_shapes->module~circle_mod module~rectangle_mod rectangle_mod program~test_shapes->module~rectangle_mod module~triangle_mod triangle_mod program~test_shapes->module~triangle_mod module~square_mod square_mod program~test_shapes->module~square_mod module~polygon_mod->module~shapes_mod module~circle_mod->module~ellipse_mod module~rectangle_mod->module~polygon_mod module~triangle_mod->module~polygon_mod module~square_mod->module~rectangle_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces get_shape_area get_shape_perimeter Derived Types shape Functions get_name Abstract Interfaces abstract interface private function get_shape_area(this) Interface for determining the area. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value real abstract interface private function get_shape_perimeter(this) Interface for determining the perimeter. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value real Derived Types type, public, abstract :: shape Base class for geometric shape types Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: name Type-Bound Procedures procedure(get_shape_area), public :: get_area procedure, public, non_overridable :: get_name procedure(get_shape_perimeter), public :: get_perimeter Functions private function get_name (this) result(name) Get the name of any defined shape. Arguments Type Intent Optional Attributes Name class( shape ), intent(in) :: this Return Value character(len=:),allocatable","tags":"","loc":"module/shapes_mod.html"},{"title":"square_mod – Testing FORD Features in a Modern Fortran Application","text":"MODULE: square_mod Define the square shape and\n create methods to obtain its features. Uses rectangle_mod module~~square_mod~~UsesGraph module~square_mod square_mod module~rectangle_mod rectangle_mod module~square_mod->module~rectangle_mod module~polygon_mod polygon_mod module~rectangle_mod->module~polygon_mod module~shapes_mod shapes_mod module~polygon_mod->module~shapes_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~square_mod~~UsedByGraph module~square_mod square_mod program~test_shapes test_shapes program~test_shapes->module~square_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces square Derived Types square Functions get_area get_perimeter new_square Interfaces public interface square private function new_square (length, name) result(a_square) Initialize a square by passing the\nthe length and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length character(len=:), allocatable :: name Return Value type( square ) Derived Types type, public, extends( rectangle ) :: square Constructor private  function new_square (length, name) Initialize a square by passing the\nthe length and a name. Type-Bound Procedures procedure, public :: get_area procedure, public, non_overridable :: get_name procedure, public :: get_perimeter Functions private function get_area (this) Deterime the area of q square. Arguments Type Intent Optional Attributes Name class( square ), intent(in) :: this Return Value real private function get_perimeter (this) Deterime the perimeter of q square. Arguments Type Intent Optional Attributes Name class( square ), intent(in) :: this Return Value real private function new_square (length, name) result(a_square) Initialize a square by passing the\nthe length and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length character(len=:), allocatable :: name Return Value type( square )","tags":"","loc":"module/square_mod.html"},{"title":"polygon_mod – Testing FORD Features in a Modern Fortran Application","text":"MODULE: polygon_mod Define the polygon shape and\n create methods to obtain its features. Uses shapes_mod module~~polygon_mod~~UsesGraph module~polygon_mod polygon_mod module~shapes_mod shapes_mod module~polygon_mod->module~shapes_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~polygon_mod~~UsedByGraph module~polygon_mod polygon_mod module~rectangle_mod rectangle_mod module~rectangle_mod->module~polygon_mod program~test_shapes test_shapes program~test_shapes->module~polygon_mod program~test_shapes->module~rectangle_mod module~triangle_mod triangle_mod program~test_shapes->module~triangle_mod module~square_mod square_mod program~test_shapes->module~square_mod module~triangle_mod->module~polygon_mod module~square_mod->module~rectangle_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces polygon Derived Types polygon Functions get_area get_perimeter new_polygon Interfaces public interface polygon private function new_polygon (xc, yc, name) Initialize an arbitrary polygon by passing the\ntwo arrays of coordinatesand and a name. Arguments Type Intent Optional Attributes Name real, target :: xc (:) real, target :: yc (:) character(len=:), allocatable :: name Return Value type( polygon ) Derived Types type, public, extends( shape ) :: polygon Derived type to define a polygon using\narrays of x and y coordinates traced in a clockwise\ndirection, starting at any vertex. Components Type Visibility Attributes Name Initial real, private, pointer :: x_coords (:) => null() real, private, pointer :: y_coords (:) => null() Constructor private  function new_polygon (xc, yc, name) Initialize an arbitrary polygon by passing the\ntwo arrays of coordinatesand and a name. Type-Bound Procedures procedure, public :: get_area procedure, public, non_overridable :: get_name procedure, public :: get_perimeter Functions private function get_area (this) result(area) Determine the area of a simple polygon. Arguments Type Intent Optional Attributes Name class( polygon ), intent(in) :: this Return Value real private function get_perimeter (this) result(perimeter) Arguments Type Intent Optional Attributes Name class( polygon ), intent(in) :: this Return Value real private function new_polygon (xc, yc, name) Initialize an arbitrary polygon by passing the\ntwo arrays of coordinatesand and a name. Arguments Type Intent Optional Attributes Name real, target :: xc (:) real, target :: yc (:) character(len=:), allocatable :: name Return Value type( polygon )","tags":"","loc":"module/polygon_mod.html"},{"title":"circle_mod – Testing FORD Features in a Modern Fortran Application","text":"MODULE: circle_mod Define the circle shape and\n create methods to obtain its features. Uses ellipse_mod module~~circle_mod~~UsesGraph module~circle_mod circle_mod module~ellipse_mod ellipse_mod module~circle_mod->module~ellipse_mod module~shapes_mod shapes_mod module~ellipse_mod->module~shapes_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~circle_mod~~UsedByGraph module~circle_mod circle_mod program~test_shapes test_shapes program~test_shapes->module~circle_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces circle Derived Types circle Functions get_area get_perimeter new_circle Subroutines print_circle_info Interfaces public interface circle private function new_circle (radius, name) result(a_circle) Initialize a circle by passing the radius\nand a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: radius character(len=:), allocatable :: name Return Value type( circle ) Derived Types type, public, extends( ellipse ) :: circle Components Type Visibility Attributes Name Initial real, private :: radius Constructor private  function new_circle (radius, name) Initialize a circle by passing the radius\nand a name. Type-Bound Procedures procedure, public :: get_area procedure, public, non_overridable :: get_name procedure, public :: get_perimeter procedure, public :: print_circle_info Functions private function get_area (this) Compute the area of a circle using the formula: Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Return Value real private function get_perimeter (this) Compute the perimeter of a circle using the formula: Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this Return Value real private function new_circle (radius, name) result(a_circle) Initialize a circle by passing the radius\nand a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: radius character(len=:), allocatable :: name Return Value type( circle ) Subroutines private subroutine print_circle_info (this) Print information (radius, area, perimeter) of a circle. Arguments Type Intent Optional Attributes Name class( circle ), intent(in) :: this","tags":"","loc":"module/circle_mod.html"},{"title":"rectangle_mod – Testing FORD Features in a Modern Fortran Application","text":"MODULE: rectangle_mod Define the rectangle shape and\n create methods to obtain its features. Uses polygon_mod module~~rectangle_mod~~UsesGraph module~rectangle_mod rectangle_mod module~polygon_mod polygon_mod module~rectangle_mod->module~polygon_mod module~shapes_mod shapes_mod module~polygon_mod->module~shapes_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~rectangle_mod~~UsedByGraph module~rectangle_mod rectangle_mod module~square_mod square_mod module~square_mod->module~rectangle_mod program~test_shapes test_shapes program~test_shapes->module~rectangle_mod program~test_shapes->module~square_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces rectangle Derived Types rectangle Functions get_area get_perimeter new_rectangle Interfaces public interface rectangle private function new_rectangle (length, width, name) result(a_rectangle) Initialize an arbitrary rectangle by passing the\nlength, the width and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length real, intent(in) :: width character(len=:), allocatable :: name Return Value type( rectangle ) Derived Types type, public, extends( polygon ) :: rectangle Components Type Visibility Attributes Name Initial real, private :: length real, private :: width Constructor private  function new_rectangle (length, width, name) Initialize an arbitrary rectangle by passing the\nlength, the width and a name. Type-Bound Procedures procedure, public :: get_area procedure, public, non_overridable :: get_name procedure, public :: get_perimeter Functions private function get_area (this) Compute the area of a reactangle Arguments Type Intent Optional Attributes Name class( rectangle ), intent(in) :: this Return Value real private function get_perimeter (this) Compute the perimeter of a reactangle Arguments Type Intent Optional Attributes Name class( rectangle ), intent(in) :: this Return Value real private function new_rectangle (length, width, name) result(a_rectangle) Initialize an arbitrary rectangle by passing the\nlength, the width and a name. Arguments Type Intent Optional Attributes Name real, intent(in) :: length real, intent(in) :: width character(len=:), allocatable :: name Return Value type( rectangle )","tags":"","loc":"module/rectangle_mod.html"},{"title":"triangle_mod – Testing FORD Features in a Modern Fortran Application","text":"MODULE: triangle_mod Define the triangle shape and \n create methods to obtain its features. Uses polygon_mod module~~triangle_mod~~UsesGraph module~triangle_mod triangle_mod module~polygon_mod polygon_mod module~triangle_mod->module~polygon_mod module~shapes_mod shapes_mod module~polygon_mod->module~shapes_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~triangle_mod~~UsedByGraph module~triangle_mod triangle_mod program~test_shapes test_shapes program~test_shapes->module~triangle_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces triangle Derived Types triangle Functions is_right_triangle get_area get_perimeter new_triangle Interfaces public interface triangle private function new_triangle (a, b, c, name) result(a_triangle) Initialize an arbitrary triangle by passing the\nthe three sides (opposite, adjacent and hypotenus) and\na name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a opposite real, intent(in) :: b adjacent real, intent(in) :: c hypotenuse character(len=:), allocatable :: name Return Value type( triangle ) Derived Types type, public, extends( polygon ) :: triangle Components Type Visibility Attributes Name Initial real, private :: a opposite real, private :: b adjacent real, private :: c hypotenus Constructor private  function new_triangle (a, b, c, name) Initialize an arbitrary triangle by passing the\nthe three sides (opposite, adjacent and hypotenus) and\na name. Type-Bound Procedures procedure, public :: get_area procedure, public, non_overridable :: get_name procedure, public :: get_perimeter Functions private function is_right_triangle (this) Determine if a triangle is a right one by\nchecking if the Pythagorean formula is true: Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value logical private function get_area (this) Compute the area of a triangle using the Heron’s formula: Read more… Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value real private function get_perimeter (this) Compute the perimeter of a triangle. Arguments Type Intent Optional Attributes Name class( triangle ), intent(in) :: this Return Value real private function new_triangle (a, b, c, name) result(a_triangle) Initialize an arbitrary triangle by passing the\nthe three sides (opposite, adjacent and hypotenus) and\na name. Arguments Type Intent Optional Attributes Name real, intent(in) :: a opposite real, intent(in) :: b adjacent real, intent(in) :: c hypotenuse character(len=:), allocatable :: name Return Value type( triangle )","tags":"","loc":"module/triangle_mod.html"},{"title":"test_shapes – Testing FORD Features in a Modern Fortran Application","text":"Uses rectangle_mod shapes_mod ellipse_mod circle_mod polygon_mod triangle_mod square_mod program~~test_shapes~~UsesGraph program~test_shapes test_shapes module~rectangle_mod rectangle_mod program~test_shapes->module~rectangle_mod module~ellipse_mod ellipse_mod program~test_shapes->module~ellipse_mod module~square_mod square_mod program~test_shapes->module~square_mod module~triangle_mod triangle_mod program~test_shapes->module~triangle_mod module~polygon_mod polygon_mod program~test_shapes->module~polygon_mod module~shapes_mod shapes_mod program~test_shapes->module~shapes_mod module~circle_mod circle_mod program~test_shapes->module~circle_mod module~rectangle_mod->module~polygon_mod module~ellipse_mod->module~shapes_mod module~square_mod->module~rectangle_mod module~triangle_mod->module~polygon_mod module~polygon_mod->module~shapes_mod module~circle_mod->module~ellipse_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Test Shapes This program is meant to test the OOP features \n (namely abstraction, encapsulation and inheritance) in Fortran. We define various geometric shapes and write functions\n to compute their area and perimeter. Contents Variables fmt fl sl name_ptr i il x_coords1 x_coords2 x_coords3 xc1 xc2 xc3 y_coords1 y_coords2 y_coords3 yc1 yc2 yc3 circ elli list poly1 poly2 poly3 rect sq etri rtri Derived Types list_of_shapes Source Code test_shapes Variables Type Attributes Name Initial character(len=16) :: fmt character(len=2) :: fl character(len=2) :: sl character(len=:), allocatable :: name_ptr integer :: i integer :: il real, dimension(4), target :: x_coords1 = [2.0, 2.0, 0.0, 0.0] real, dimension(3), target :: x_coords2 = [0.0, 3.0, 3.0] real, dimension(6), target :: x_coords3 = [4.0, 4.0, 8.0, 8.0, -4.0, -4.0] real, pointer :: xc1 (:) real, pointer :: xc2 (:) real, pointer :: xc3 (:) real, dimension(4), target :: y_coords1 = [2.0, -2.0, -2.0, 2.0] real, dimension(3), target :: y_coords2 = [0.0, 4.0, 0.0] real, dimension(6), target :: y_coords3 = [6.0, -4.0, -4.0, -8.0, -8.0, 6.0] real, pointer :: yc1 (:) real, pointer :: yc2 (:) real, pointer :: yc3 (:) type( circle ), target :: circ type( ellipse ), target :: elli type( list_of_shapes ), dimension(9) :: list type( polygon ), target :: poly1 type( polygon ), target :: poly2 type( polygon ), target :: poly3 type( rectangle ), target :: rect type( square ), target :: sq type( triangle ), target :: etri type( triangle ), target :: rtri Derived Types type :: list_of_shapes Components Type Visibility Attributes Name Initial class( shape ), public, pointer :: shap Source Code program test_shapes use shapes_mod use polygon_mod use rectangle_mod use square_mod use triangle_mod use ellipse_mod use circle_mod implicit none type ( ellipse ), target :: elli type ( circle ), target :: circ type ( polygon ), target :: poly1 , poly2 , poly3 type ( rectangle ), target :: rect type ( square ), target :: sq type ( triangle ), target :: etri , rtri type list_of_shapes class ( shape ), pointer :: shap end type list_of_shapes type ( list_of_shapes ), dimension ( 9 ) :: list ! For an irregular polygon, we need coordinates. ! Test #1 Area=8, perim=12 real , dimension ( 4 ), target :: x_coords1 = [ 2.0 , 2.0 , 0.0 , 0.0 ] real , dimension ( 4 ), target :: y_coords1 = [ 2.0 , - 2.0 , - 2.0 , 2.0 ] ! Test #2 Area=6, perim=12 real , dimension ( 3 ), target :: x_coords2 = [ 0.0 , 3.0 , 3.0 ] ! a=6 real , dimension ( 3 ), target :: y_coords2 = [ 0.0 , 4.0 , 0.0 ] ! p=12 ! Test #3 Area=128, perim=52 real , dimension ( 6 ), target :: x_coords3 = [ 4.0 , 4.0 , 8.0 , 8.0 , - 4.0 , - 4.0 ] real , dimension ( 6 ), target :: y_coords3 = [ 6.0 , - 4.0 , - 4.0 , - 8.0 , - 8.0 , 6.0 ] real , pointer :: xc1 (:), yc1 (:), xc2 (:), yc2 (:), xc3 (:), yc3 (:) character ( len = :), allocatable :: name_ptr integer :: i ! formatting character ( len = 2 ) :: sl , fl character ( len = 16 ) :: fmt integer il ! Ellipses: elli = ellipse ( a = 1 0.0 , b = 5.0 , name = 'ellipse(a=10,b=5)' ) name_ptr = 'circle(r=1)' circ = circle ( 1.0 , name_ptr ) ! Create various Polygons xc1 => x_coords1 yc1 => y_coords1 poly1 = polygon ( x_coords = xc1 , y_coords = yc1 , name = 'polygon1' ) xc2 => x_coords2 yc2 => y_coords2 poly2 = polygon ( x_coords = xc2 , y_coords = yc2 , name = 'polygon2' ) xc3 => x_coords3 yc3 => y_coords3 poly3 = polygon ( x_coords = xc3 , y_coords = yc3 , name = 'polygon3' ) name_ptr = 'rectangle(3x2)' rect = rectangle ( length = 3.0 , width = 2.0 , name = name_ptr ) name_ptr = 'square(3x3)' sq = square ( 3.0 , name_ptr ) name_ptr = 'triangle(5x5x5)' etri = triangle ( a = 5.0 , b = 5.0 , c = 5.0 , name = name_ptr ) name_ptr = 'triangle(3x4x5)' rtri = triangle ( a = 3.0 , b = 4.0 , c = 5.0 , name = name_ptr ) list ( 1 )% shap => elli list ( 2 )% shap => circ list ( 3 )% shap => poly1 list ( 4 )% shap => poly2 list ( 5 )% shap => poly3 list ( 6 )% shap => rect list ( 7 )% shap => sq list ( 8 )% shap => etri list ( 9 )% shap => rtri write ( 6 , '(1x,a,a)' ) 'Object                  Area        Perimeter' write ( 6 , '(1x,a)' ) '---------------------------------------------' do i = 1 , size ( list ) write ( fl , '(i0)' ) len ( trim ( list ( i )% shap % get_name ())) il = 24 - len ( trim ( list ( i )% shap % get_name ())) write ( sl , '(i2)' ) il write ( fmt , \"(a)\" ) '(1x,a' // fl // ',' // sl // 'x)' write ( 6 , fmt , advance = 'no' ) adjustl ( list ( i )% shap % get_name ()) write ( 6 , '(2(f8.4,4x))' ) list ( i )% shap % get_area (), list ( i )% shap % get_perimeter () end do end program test_shapes","tags":"","loc":"program/test_shapes.html"},{"title":"ellipse_mod.F90 – Testing FORD Features in a Modern Fortran Application","text":"This file depends on sourcefile~~ellipse_mod.f90~~EfferentGraph sourcefile~ellipse_mod.f90 ellipse_mod.F90 sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~ellipse_mod.f90->sourcefile~shapes_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ellipse_mod.f90~~AfferentGraph sourcefile~ellipse_mod.f90 ellipse_mod.F90 sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~test_shapes.f90->sourcefile~ellipse_mod.f90 sourcefile~circle_mod.f90 circle_mod.F90 sourcefile~test_shapes.f90->sourcefile~circle_mod.f90 sourcefile~circle_mod.f90->sourcefile~ellipse_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ellipse_mod Source Code ellipse_mod.F90 Source Code !> !### MODULE: `ellipse_mod` ! ! Define the ellipse shape and ! create methods to obtain its features. ! module ellipse_mod use shapes_mod implicit none private public ellipse type , extends ( shape ) :: ellipse real :: a !! semi-major axe real :: b !! semi-minor axe contains procedure :: get_area procedure :: get_perimeter end type ellipse interface ellipse procedure new_ellipse end interface ellipse real , parameter , public :: PI = 4.0 * atan ( 1.0 ) contains !> ! Initialize an arbitrary ellipse by passing the ! the  semi-major and semi-minor axes, and a name. ! function new_ellipse ( a , b , name ) result ( a_ellipse ) real , intent ( in ) :: a ! semi-major axe real , intent ( in ) :: b ! semi-minor axe character ( len = :), allocatable :: name type ( ellipse ) :: a_ellipse a_ellipse % a = a a_ellipse % b = b a_ellipse % name = name end function new_ellipse !> ! Compute the area of an ellipse using the formula: ! !  A = \\pi \\times a \\times b  ! real function get_area ( this ) class ( ellipse ), intent ( in ) :: this get_area = PI * this % a * this % b end function get_area !> ! Compute the perimeter of an ellipse using the formula: ! ! !\\begin{align} \\label{eqn} ! h & =  \\frac{(a-b)&#94;2}{(a+b)&#94;2} \\\\ ! t & =  1 + \\frac{1}{4}h + \\frac{1}{64}h&#94;2 + \\frac{1}{256}h&#94;3 + \\frac{25}{16384}h&#94;4 + \\frac{49}{65536}h&#94;5 + \\frac{441}{1048576}h&#94;6 \\\\ ! P & =  \\pi \\times (a+b) \\times t !\\end{align} ! ! real function get_perimeter ( this ) class ( ellipse ), intent ( in ) :: this real :: h , terms integer :: i h = ( ( this % a - this % b ) ** 2 ) / ( ( this % a + this % b ) ** 2 ) terms = 1.0 + 0.25 * h + ( 1. / 6 4. ) * h ** 2 + ( 1. / 25 6. ) * h ** 3 + & ( 2 5. / 1638 4. ) * h ** 4 + ( 4 9. / 6553 6. ) * h ** 5 + ( 44 1. / 104857 6. ) * h ** 6 get_perimeter = PI * ( this % a + this % b ) * terms !      ! Ramanujan's approximation !      associate (a=>this%a, b=>this%b) !        get_perimeter = PI * (3.0*(a+b) - sqrt( (3.0*a+b)*(a+3.0*b) )) !      end associate end function get_perimeter end module ellipse_mod","tags":"","loc":"sourcefile/ellipse_mod.f90.html"},{"title":"shapes_mod.F90 – Testing FORD Features in a Modern Fortran Application","text":"Files dependent on this one sourcefile~~shapes_mod.f90~~AfferentGraph sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~ellipse_mod.f90 ellipse_mod.F90 sourcefile~ellipse_mod.f90->sourcefile~shapes_mod.f90 sourcefile~polygon_mod.f90 polygon_mod.F90 sourcefile~polygon_mod.f90->sourcefile~shapes_mod.f90 sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~test_shapes.f90->sourcefile~shapes_mod.f90 sourcefile~test_shapes.f90->sourcefile~ellipse_mod.f90 sourcefile~test_shapes.f90->sourcefile~polygon_mod.f90 sourcefile~circle_mod.f90 circle_mod.F90 sourcefile~test_shapes.f90->sourcefile~circle_mod.f90 sourcefile~rectangle_mod.f90 rectangle_mod.F90 sourcefile~test_shapes.f90->sourcefile~rectangle_mod.f90 sourcefile~triangle_mod.f90 triangle_mod.F90 sourcefile~test_shapes.f90->sourcefile~triangle_mod.f90 sourcefile~square_mod.f90 square_mod.F90 sourcefile~test_shapes.f90->sourcefile~square_mod.f90 sourcefile~circle_mod.f90->sourcefile~ellipse_mod.f90 sourcefile~rectangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~triangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~square_mod.f90->sourcefile~rectangle_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules shapes_mod Source Code shapes_mod.F90 Source Code !> !### MODULE: `shape_class` ! ! Parent class that will be used to define various geometric shapes. ! ! For aech define shape, we want to be to determine its area and perimeter. ! module shapes_mod implicit none private public shape type , abstract :: shape !! Base class for geometric shape types character ( len = :), allocatable :: name contains procedure ( get_shape_area ), deferred :: get_area procedure ( get_shape_perimeter ), deferred :: get_perimeter procedure , non_overridable :: get_name end type shape abstract interface real function get_shape_area ( this ) !! Interface for determining the area. import :: shape class ( shape ), intent ( in ) :: this end function get_shape_area end interface abstract interface real function get_shape_perimeter ( this ) !! Interface for determining the perimeter. import :: shape class ( shape ), intent ( in ) :: this end function get_shape_perimeter end interface contains !> ! Get the name of any defined shape. function get_name ( this ) result ( name ) class ( shape ), intent ( in ) :: this character ( len = :), allocatable :: name name = this % name end function get_name end module shapes_mod","tags":"","loc":"sourcefile/shapes_mod.f90.html"},{"title":"square_mod.F90 – Testing FORD Features in a Modern Fortran Application","text":"This file depends on sourcefile~~square_mod.f90~~EfferentGraph sourcefile~square_mod.f90 square_mod.F90 sourcefile~rectangle_mod.f90 rectangle_mod.F90 sourcefile~square_mod.f90->sourcefile~rectangle_mod.f90 sourcefile~polygon_mod.f90 polygon_mod.F90 sourcefile~rectangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~polygon_mod.f90->sourcefile~shapes_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~square_mod.f90~~AfferentGraph sourcefile~square_mod.f90 square_mod.F90 sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~test_shapes.f90->sourcefile~square_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules square_mod Source Code square_mod.F90 Source Code !> !### MODULE: `square_mod` ! ! Define the square shape and ! create methods to obtain its features. ! module square_mod use rectangle_mod implicit none private public square type , extends ( rectangle ) :: square contains procedure :: get_area procedure :: get_perimeter end type square interface square procedure new_square end interface square contains !> ! Initialize a square by passing the ! the length and a name. function new_square ( length , name ) result ( a_square ) real , intent ( in ) :: length character ( len = :), allocatable :: name type ( square ) :: a_square a_square % length = length a_square % name = name end function new_square !> ! Deterime the area of q square. real function get_area ( this ) class ( square ), intent ( in ) :: this get_area = this % length * this % length end function get_area !> ! Deterime the perimeter of q square. real function get_perimeter ( this ) class ( square ), intent ( in ) :: this get_perimeter = 4.0 * this % length end function get_perimeter end module square_mod","tags":"","loc":"sourcefile/square_mod.f90.html"},{"title":"polygon_mod.F90 – Testing FORD Features in a Modern Fortran Application","text":"This file depends on sourcefile~~polygon_mod.f90~~EfferentGraph sourcefile~polygon_mod.f90 polygon_mod.F90 sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~polygon_mod.f90->sourcefile~shapes_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~polygon_mod.f90~~AfferentGraph sourcefile~polygon_mod.f90 polygon_mod.F90 sourcefile~rectangle_mod.f90 rectangle_mod.F90 sourcefile~rectangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~test_shapes.f90->sourcefile~polygon_mod.f90 sourcefile~test_shapes.f90->sourcefile~rectangle_mod.f90 sourcefile~triangle_mod.f90 triangle_mod.F90 sourcefile~test_shapes.f90->sourcefile~triangle_mod.f90 sourcefile~square_mod.f90 square_mod.F90 sourcefile~test_shapes.f90->sourcefile~square_mod.f90 sourcefile~triangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~square_mod.f90->sourcefile~rectangle_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules polygon_mod Source Code polygon_mod.F90 Source Code !> !### MODULE: `polygon_mod` ! ! Define the polygon shape and ! create methods to obtain its features. ! module polygon_mod use shapes_mod implicit none private public polygon type , extends ( shape ) :: polygon !! Derived type to define a polygon using !! arrays of x and y coordinates traced in a clockwise !! direction, starting at any vertex. real , pointer :: x_coords (:) => null () real , pointer :: y_coords (:) => null () contains procedure :: get_area procedure :: get_perimeter end type polygon interface polygon procedure new_polygon end interface polygon contains !> ! Initialize an arbitrary polygon by passing the ! two arrays of coordinatesand and a name. function new_polygon ( xc , yc , name ) real , target :: xc (:) real , target :: yc (:) character ( len = :), allocatable :: name type ( polygon ) :: new_polygon new_polygon % x_coords => xc new_polygon % y_coords => yc new_polygon % name = name end function new_polygon !> ! Determine the area of a simple polygon. function get_area ( this ) result ( area ) class ( polygon ), intent ( in ) :: this real :: area integer :: i , num_points area = 0.0 num_points = size ( this % x_coords ) associate ( x => this % x_coords , y => this % y_coords , n => num_points ) do i = 1 , n - 1 area = area + ( x ( i ) * y ( i + 1 )) - ( x ( i + 1 ) * y ( i )) end do area = area + x ( n ) * y ( 1 ) - x ( 1 ) * y ( n ) end associate area = abs ( area ) / 2.0 end function get_area ! Determine the perimeter of a polygon. function get_perimeter ( this ) result ( perimeter ) class ( polygon ), intent ( in ) :: this real :: perimeter integer :: i , num_points perimeter = 0.0 num_points = size ( this % x_coords ) associate ( x => this % x_coords , y => this % y_coords , n => num_points ) do i = 1 , n - 1 perimeter = perimeter + sqrt ( ( x ( i + 1 ) - x ( i )) ** 2 + ( y ( i + 1 ) - y ( i )) ** 2 ) end do ! last point perimeter = perimeter + sqrt ( ( x ( 1 ) - x ( n )) ** 2 + ( y ( 1 ) - y ( n )) ** 2 ) end associate end function get_perimeter end module polygon_mod","tags":"","loc":"sourcefile/polygon_mod.f90.html"},{"title":"test_shapes.F90 – Testing FORD Features in a Modern Fortran Application","text":"This file depends on sourcefile~~test_shapes.f90~~EfferentGraph sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~circle_mod.f90 circle_mod.F90 sourcefile~test_shapes.f90->sourcefile~circle_mod.f90 sourcefile~polygon_mod.f90 polygon_mod.F90 sourcefile~test_shapes.f90->sourcefile~polygon_mod.f90 sourcefile~rectangle_mod.f90 rectangle_mod.F90 sourcefile~test_shapes.f90->sourcefile~rectangle_mod.f90 sourcefile~ellipse_mod.f90 ellipse_mod.F90 sourcefile~test_shapes.f90->sourcefile~ellipse_mod.f90 sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~test_shapes.f90->sourcefile~shapes_mod.f90 sourcefile~triangle_mod.f90 triangle_mod.F90 sourcefile~test_shapes.f90->sourcefile~triangle_mod.f90 sourcefile~square_mod.f90 square_mod.F90 sourcefile~test_shapes.f90->sourcefile~square_mod.f90 sourcefile~circle_mod.f90->sourcefile~ellipse_mod.f90 sourcefile~polygon_mod.f90->sourcefile~shapes_mod.f90 sourcefile~rectangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~ellipse_mod.f90->sourcefile~shapes_mod.f90 sourcefile~triangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~square_mod.f90->sourcefile~rectangle_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs test_shapes Source Code test_shapes.F90 Source Code !> !# Test Shapes ! ! This program is meant to test the OOP features ! (namely abstraction, encapsulation and inheritance) in Fortran. ! ! We define various geometric shapes and write functions ! to compute their area and perimeter. ! program test_shapes use shapes_mod use polygon_mod use rectangle_mod use square_mod use triangle_mod use ellipse_mod use circle_mod implicit none type ( ellipse ), target :: elli type ( circle ), target :: circ type ( polygon ), target :: poly1 , poly2 , poly3 type ( rectangle ), target :: rect type ( square ), target :: sq type ( triangle ), target :: etri , rtri type list_of_shapes class ( shape ), pointer :: shap end type list_of_shapes type ( list_of_shapes ), dimension ( 9 ) :: list ! For an irregular polygon, we need coordinates. ! Test #1 Area=8, perim=12 real , dimension ( 4 ), target :: x_coords1 = [ 2.0 , 2.0 , 0.0 , 0.0 ] real , dimension ( 4 ), target :: y_coords1 = [ 2.0 , - 2.0 , - 2.0 , 2.0 ] ! Test #2 Area=6, perim=12 real , dimension ( 3 ), target :: x_coords2 = [ 0.0 , 3.0 , 3.0 ] ! a=6 real , dimension ( 3 ), target :: y_coords2 = [ 0.0 , 4.0 , 0.0 ] ! p=12 ! Test #3 Area=128, perim=52 real , dimension ( 6 ), target :: x_coords3 = [ 4.0 , 4.0 , 8.0 , 8.0 , - 4.0 , - 4.0 ] real , dimension ( 6 ), target :: y_coords3 = [ 6.0 , - 4.0 , - 4.0 , - 8.0 , - 8.0 , 6.0 ] real , pointer :: xc1 (:), yc1 (:), xc2 (:), yc2 (:), xc3 (:), yc3 (:) character ( len = :), allocatable :: name_ptr integer :: i ! formatting character ( len = 2 ) :: sl , fl character ( len = 16 ) :: fmt integer il ! Ellipses: elli = ellipse ( a = 1 0.0 , b = 5.0 , name = 'ellipse(a=10,b=5)' ) name_ptr = 'circle(r=1)' circ = circle ( 1.0 , name_ptr ) ! Create various Polygons xc1 => x_coords1 yc1 => y_coords1 poly1 = polygon ( x_coords = xc1 , y_coords = yc1 , name = 'polygon1' ) xc2 => x_coords2 yc2 => y_coords2 poly2 = polygon ( x_coords = xc2 , y_coords = yc2 , name = 'polygon2' ) xc3 => x_coords3 yc3 => y_coords3 poly3 = polygon ( x_coords = xc3 , y_coords = yc3 , name = 'polygon3' ) name_ptr = 'rectangle(3x2)' rect = rectangle ( length = 3.0 , width = 2.0 , name = name_ptr ) name_ptr = 'square(3x3)' sq = square ( 3.0 , name_ptr ) name_ptr = 'triangle(5x5x5)' etri = triangle ( a = 5.0 , b = 5.0 , c = 5.0 , name = name_ptr ) name_ptr = 'triangle(3x4x5)' rtri = triangle ( a = 3.0 , b = 4.0 , c = 5.0 , name = name_ptr ) list ( 1 )% shap => elli list ( 2 )% shap => circ list ( 3 )% shap => poly1 list ( 4 )% shap => poly2 list ( 5 )% shap => poly3 list ( 6 )% shap => rect list ( 7 )% shap => sq list ( 8 )% shap => etri list ( 9 )% shap => rtri write ( 6 , '(1x,a,a)' ) 'Object                  Area        Perimeter' write ( 6 , '(1x,a)' ) '---------------------------------------------' do i = 1 , size ( list ) write ( fl , '(i0)' ) len ( trim ( list ( i )% shap % get_name ())) il = 24 - len ( trim ( list ( i )% shap % get_name ())) write ( sl , '(i2)' ) il write ( fmt , \"(a)\" ) '(1x,a' // fl // ',' // sl // 'x)' write ( 6 , fmt , advance = 'no' ) adjustl ( list ( i )% shap % get_name ()) write ( 6 , '(2(f8.4,4x))' ) list ( i )% shap % get_area (), list ( i )% shap % get_perimeter () end do end program test_shapes","tags":"","loc":"sourcefile/test_shapes.f90.html"},{"title":"circle_mod.F90 – Testing FORD Features in a Modern Fortran Application","text":"This file depends on sourcefile~~circle_mod.f90~~EfferentGraph sourcefile~circle_mod.f90 circle_mod.F90 sourcefile~ellipse_mod.f90 ellipse_mod.F90 sourcefile~circle_mod.f90->sourcefile~ellipse_mod.f90 sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~ellipse_mod.f90->sourcefile~shapes_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~circle_mod.f90~~AfferentGraph sourcefile~circle_mod.f90 circle_mod.F90 sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~test_shapes.f90->sourcefile~circle_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules circle_mod Source Code circle_mod.F90 Source Code !> !### MODULE: `circle_mod` ! ! Define the circle shape and ! create methods to obtain its features. ! module circle_mod use ellipse_mod implicit none private public circle type , extends ( ellipse ) :: circle real :: radius contains procedure :: get_area procedure :: get_perimeter procedure :: print_circle_info end type circle interface circle procedure new_circle end interface circle contains !> ! Initialize a circle by passing the radius ! and a name. function new_circle ( radius , name ) result ( a_circle ) real , intent ( in ) :: radius character ( len = :), allocatable :: name type ( circle ) :: a_circle a_circle % radius = radius a_circle % name = name end function new_circle !> ! Compute the area of a circle using the formula: !  A = \\pi \\times r&#94;2  ! real function get_area ( this ) class ( circle ), intent ( in ) :: this get_area = PI * this % radius ** 2 end function get_area !> ! Compute the perimeter of a circle using the formula: !  P = 2 \\times \\pi \\times r  ! real function get_perimeter ( this ) class ( circle ), intent ( in ) :: this get_perimeter = 2.0 * PI * this % radius end function get_perimeter !> ! Print information (radius, area, perimeter) of a circle. subroutine print_circle_info ( this ) class ( circle ), intent ( in ) :: this area = circle_area ( this ) ! Call the circle_area function print '(a15)' , 'Circle:' print '(a18)' , '      Radius = ' , this % radius print '(a18)' , '        Area = ' , get_area ( this ) print '(a18)' , '   Perimeter = ' , get_perimeter ( this ) print * , 'Circle: r = ' , this % radius , ' area = ' , area end subroutine print_circle_info end module circle_mod","tags":"","loc":"sourcefile/circle_mod.f90.html"},{"title":"rectangle_mod.F90 – Testing FORD Features in a Modern Fortran Application","text":"This file depends on sourcefile~~rectangle_mod.f90~~EfferentGraph sourcefile~rectangle_mod.f90 rectangle_mod.F90 sourcefile~polygon_mod.f90 polygon_mod.F90 sourcefile~rectangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~polygon_mod.f90->sourcefile~shapes_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~rectangle_mod.f90~~AfferentGraph sourcefile~rectangle_mod.f90 rectangle_mod.F90 sourcefile~square_mod.f90 square_mod.F90 sourcefile~square_mod.f90->sourcefile~rectangle_mod.f90 sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~test_shapes.f90->sourcefile~rectangle_mod.f90 sourcefile~test_shapes.f90->sourcefile~square_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules rectangle_mod Source Code rectangle_mod.F90 Source Code !> !### MODULE: `rectangle_mod` ! ! Define the rectangle shape and ! create methods to obtain its features. ! module rectangle_mod use polygon_mod implicit none private public rectangle type , extends ( polygon ) :: rectangle real :: length real :: width contains procedure :: get_area procedure :: get_perimeter end type rectangle interface rectangle procedure new_rectangle end interface rectangle contains !> ! Initialize an arbitrary rectangle by passing the ! length, the width and a name. function new_rectangle ( length , width , name ) result ( a_rectangle ) real , intent ( in ) :: length , width character ( len = :), allocatable :: name type ( rectangle ) :: a_rectangle a_rectangle % length = length a_rectangle % width = width a_rectangle % name = name end function new_rectangle !> ! Compute the area of a reactangle real function get_area ( this ) class ( rectangle ), intent ( in ) :: this get_area = this % width * this % length end function get_area !> ! Compute the perimeter of a reactangle real function get_perimeter ( this ) class ( rectangle ), intent ( in ) :: this get_perimeter = 2.0 * ( this % width + this % length ) end function get_perimeter end module rectangle_mod","tags":"","loc":"sourcefile/rectangle_mod.f90.html"},{"title":"triangle_mod.F90 – Testing FORD Features in a Modern Fortran Application","text":"This file depends on sourcefile~~triangle_mod.f90~~EfferentGraph sourcefile~triangle_mod.f90 triangle_mod.F90 sourcefile~polygon_mod.f90 polygon_mod.F90 sourcefile~triangle_mod.f90->sourcefile~polygon_mod.f90 sourcefile~shapes_mod.f90 shapes_mod.F90 sourcefile~polygon_mod.f90->sourcefile~shapes_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~triangle_mod.f90~~AfferentGraph sourcefile~triangle_mod.f90 triangle_mod.F90 sourcefile~test_shapes.f90 test_shapes.F90 sourcefile~test_shapes.f90->sourcefile~triangle_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules triangle_mod Source Code triangle_mod.F90 Source Code !> !### MODULE: `triangle_mod` ! ! Define the triangle shape and ! create methods to obtain its features. ! module triangle_mod use polygon_mod implicit none private public triangle type , extends ( polygon ) :: triangle real :: a !! opposite real :: b !! adjacent real :: c !! hypotenus contains procedure :: get_area procedure :: get_perimeter end type triangle interface triangle procedure new_triangle end interface triangle contains !> ! Initialize an arbitrary triangle by passing the ! the three sides (opposite, adjacent and hypotenus) and ! a name. function new_triangle ( a , b , c , name ) result ( a_triangle ) real , intent ( in ) :: a !! opposite real , intent ( in ) :: b !! adjacent real , intent ( in ) :: c !! hypotenuse character ( len = :), allocatable :: name type ( triangle ) :: a_triangle a_triangle % a = a a_triangle % b = b a_triangle % c = c a_triangle % name = name end function new_triangle !> ! Compute the area of a triangle using the Heron's formula: ! ! !\\begin{align} !s & =  \\frac{a+b+c}{2} \\\\ !A & =  \\sqrt{s(s-a)(s-b)(s-c)} !\\end{align} ! ! real function get_area ( this ) class ( triangle ), intent ( in ) :: this real :: s s = ( this % a + this % b + this % c ) / 2.0 get_area = sqrt ( s * ( s - this % a ) * ( s - this % b ) * ( s - this % c )) end function get_area !> ! Compute the perimeter of a triangle. real function get_perimeter ( this ) class ( triangle ), intent ( in ) :: this get_perimeter = this % a + this % b + this % c end function get_perimeter !> ! Determine if a triangle is a right one by ! checking if the Pythagorean formula is true: !  c&#94;2 = a&#94;2 + b&#94;2  logical function is_right_triangle ( this ) class ( triangle ), intent ( in ) :: this is_right_triangle = . FALSE . if ( ( this % a ** 2 + this % b ** 2 ) == this % c ** 2 ) is_right_triangle = . TRUE . end function is_right_triangle end module triangle_mod","tags":"","loc":"sourcefile/triangle_mod.f90.html"}]}